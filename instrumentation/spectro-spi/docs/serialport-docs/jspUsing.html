<!--
  ~ Copyright (c) 2011 Niclas Hedhman.
  ~
  ~ Licensed  under the  Apache License, Version 2.0  (the "License");
  ~ you may not use  this file  except in  compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed  under the  License is distributed on an "AS IS" BASIS,
  ~ WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or
  ~ implied.
  ~
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
    <META NAME="GENERATOR" Content="Visual Page 2.0 for Windows">
    <TITLE>jspUsing</TITLE>
</HEAD>

<BODY>

<P ALIGN="CENTER"><B><U><FONT SIZE="6">SerialPort</FONT></U></B> <BR>
    <FONT SIZE="4">The Java Tool For Serial Ports</FONT> <BR>
    <FONT SIZE="4">Version 5.0</FONT></P>

<P><FONT SIZE="5">Using SerialPort</FONT></P>

<P>In addition to the JavaTerm source code, simple console example applications that use SerialPort are provided.
    For the location of these files see the jspReadme.html file. The example files are all console based applications
    and therefore should not be considered &quot;Mac Friendly&quot;.</P>

<P>To use SerialPort, you first create a SerialConfig object, adjust the settings as desired, the create a SerialPort
    object by passing the SerialConfig object as a parameter.

<UL>
    <TT>int port = 2; //COM2. Use open-by-name on Unix (see below)</TT> <BR>
    <TT>int txBuf = 2048;</TT> <BR>
    <TT>int rebuff = 4096;</TT> <BR>
    <TT>SerialConfig serCfg;</TT> <BR>
    <TT>SerialPort p;</TT>

    <P><TT>try {</TT> <BR>
        <TT>&nbsp; serCfg = new SerialConfig(port, txBuf, rxBuf);</TT> <BR>
        <TT>&nbsp; serCfg.setBitRate(SerialConfig.BR_19200);</TT> <BR>
        <TT>&nbsp; serCfg.setDataBits(SerialConfig.LN_8BITS);</TT> <BR>
        <TT>&nbsp; serCfg.setStopBits(SerialConfig.ST_1BITS);</TT> <BR>
        <TT>&nbsp; serCfg.setParity(SerialConfig.PY_NONE);</TT> <BR>
        <TT>&nbsp; serCfg.setHandshake(SerialConfig.HS_CTSRTS);</TT> <BR>
        <TT>&nbsp; p = new SerialPortLocal(serCfg);</TT> <BR>
        <TT>&nbsp; p.putString(&quot;Hello!&quot;);</TT> <BR>
        <TT>&nbsp; }</TT> <BR>
        <TT>&nbsp; catch (IOException e) {</TT> <BR>
        <TT>&nbsp;&nbsp;&nbsp; System.out.println(e);</TT> <BR>
        <TT>&nbsp; }</TT>
</UL>

<P>You can also create the SerialPort object, change the configuration object, then reconfigure the port.

<UL>
    <TT>int port = 2; //COM2</TT> <TT>Use open-by-name on Unix (see below)</TT> <BR>
    <TT>SerialConfig serCfg;</TT> <BR>
    <TT>SerialPort p;</TT>

    <P><TT>try {</TT> <BR>
        <TT>&nbsp; serCfg = new SerialConfig(port); //use default buffer sizes</TT> <BR>
        <TT>&nbsp; p = new SerialPortLocal(serCfg);</TT> <BR>
        <TT>&nbsp; serCfg.setBitRate(SerialConfig.BR_19200);</TT> <BR>
        <TT>&nbsp; serCfg.setDataBits(SerialConfig.LN_8BITS);</TT> <BR>
        <TT>&nbsp; serCfg.setStopBits(SerialConfig.LN_1BITS);</TT> <BR>
        <TT>&nbsp; serCfg.setParity(SerialConfig.PY_NONE);</TT> <BR>
        <TT>&nbsp; serCfg.setHandshake(SerialConfig.HS_CTSRTS);</TT> <BR>
        <TT>&nbsp; p.configure();</TT> <BR>
        <TT>&nbsp; p.putString(&quot;Hello!&quot;);</TT> <BR>
        <TT>&nbsp; }</TT> <BR>
        <TT>&nbsp; catch (IOException e) {</TT> <BR>
        <TT>&nbsp;&nbsp;&nbsp; System.out.println(e);</TT> <BR>
        <TT>&nbsp; }</TT>
</UL>

<P>SerialPort objects may also be constructed by name as shown below. This only works for JNI compliant VM's so
    this mode is not currently supported for Microsoft Java. This should not be an issue since Microsoft Java only
    runs on Windows, and Windows serial devices have the name COM followed by a number. Note that when a device is
    opened by name, the port number returned from the SerialConfig object may be meaningless.

<UL>
    <TT>String BarCodeReader = &quot;/dev/ttyR3&quot;;</TT> <BR>
    <TT>String modem = &quot;/dev/modem&quot;;</TT> <BR>
    <TT>SerialConfig mdmCfg, bcCfg;</TT> <BR>
    <TT>SerialPort mdm, bcr;</TT>

    <P><TT>try {</TT> <BR>
        <TT>&nbsp; mdmCfg = new SerialConfig(modem);&nbsp; //Open-by-name</TT> <BR>
        <TT>&nbsp; bcCfg = new SerialPortLocal(BarCodeReader);</TT> <BR>
        <TT>&nbsp; mdm = new SerialConfig(mdmCfg);</TT> <BR>
        <TT>&nbsp; bcr = new SerialPortLocal(bcfg);</TT> <BR>
        <TT>&nbsp; }</TT> <BR>
        <TT>&nbsp; catch (IOException e) {</TT> <BR>
        <TT>&nbsp;&nbsp;&nbsp; System.out.println(e);</TT> <BR>
        <TT>&nbsp; }</TT>
</UL>

<P>If the native OS supports a 'Registry' functionality, you can determine a list of serial ports by using the
    method SerialPortLocal.getPortList(). For example the following code displays a list of ports that are entered
    in the OS 'Registry'.</P>

<P><TT>&nbsp;String[] names = SerialPortLocal.getPortList();</TT> <BR>
    <TT>&nbsp;System.out.println(&quot;Serial ports reported by system:&quot;);</TT> <BR>
    <TT>&nbsp;for (int i = 0; i &lt; names.length; i++) {</TT> <BR>
    <TT>&nbsp; System.out.println(names[i]);</TT> <BR>
    <TT>&nbsp;}</TT> <BR>
    &nbsp;</P>

<P><B>Define Available Serial Ports</B> <BR>
    A list of serial port names can be passed to SerialPort. When passed, the list is used to determine which ports
    are available when using the getPortList() method and the Comm API. The list must contain a semi-colon delimited
    list of port names, for example</P>

<P><TT>&nbsp;&nbsp;&nbsp; SERIAL_PORT_LIST=COM1;COM2;COM3</TT></P>

<P>When the property <TT>SERIAL_PORT_LIST</TT> is undefined then an attempt is made to determine the list of available
    ports using native methods. Note that not all platforms support native port discovery. A system property can be
    set from the command line with most modern VM's. For example</P>

<P><TT>&nbsp;&nbsp;&nbsp; java -DSERIAL_PORT_LIST=COM1;COM2;COM3 JavaTerm</TT></P>

<P><B>Cloning SerialConfig Objects</B> <BR>
    It can sometimes be convienent to clone configuration objects for simple configuration changes of a SerialPort
    object. SerialConfig is clonable to allow for this. If for example, you have two configurations that differ
    slightly,
    you can create the first, clone it then modify the configuration of the second object. You will then have two
    different
    SerialConfig objects that can be used to alternatively modify a SerialPort configuration.</P>

<P><B>Transmit and Receive Buffers</B> <BR>
    Since buffer sizes are implemented differently on different platforms, when you create a SerialPort object with
    buffer sizes other than the defaults, the port may not actual be configured with these values. There are two reasons
    for this. The first reason relates to limitations placed on SerialPort by the underlying Operating System (OS).
    Some OSs (e.g. most Unix implementations) do not allow modification of these values without reconstruction of the
    kernel. The second reason stems from driver implementations on some OSs. An example of this would be using a Comtrol
    RocketPort on Win95 or WinNT. The Comtrol RocketPort has 1024 byte hardware receive and transmit buffers, so the
    driver will not allow adjustment of the receive and transmit buffers to values less than 4096 bytes. When a
    SerialPort
    is created using buffer sizes less than the defaults the defaults are used. When you use the default Win32 COMM
    driver the buffer values can be made much smaller. Unless you have some special reason for small buffers we
    recommend
    you never use values less than the SerialPort defaults.</P>

<P><B>What does <I>flush</I> mean?</B> <BR>
    It is a common mistake to confuse <I>flushing</I> and <I>draining</I> the serial port transmit queue. This confusion
    is mostly due to normal behaviour of a file stream when flushed. A flush done to a file stream causes the contents
    to be written to disk. The term flush for a serial port is historically different from a file, and when a serial
    port is flushed the queue contents are <I>discarded</I>. If you wish to ensure the contents of the transmit queue
    are sent to the port, then the commonly used term is to <I>drain</I> the queue. Now to add to the confusion, when
    using an <I>outputstream</I> on a serial port (e.g. SerOutputStream) flushing means the same thing as a file stream
    where <I>flushing writes</I>, the contents. So for serial ports&nbsp; <I>flushing</I> <I>discards</I> while <I>draining
        writes</I> and for serial port streams&nbsp; <I>flushing writes.</I></P>

<P><B>Draining the transmit queue</B> <BR>
    For increased performance, beginning with SerialPort 3.2 the write calls (putByte/putData/putString) do not drain
    the transmit queue before returning. For applications that need to insure the transmit queue is drained at some
    point of time (e.g. before closing the port) txDrain or checking the txBufCount should be used. If your application
    works on one platform and appears to not transmit all bytes sent to the port on another platform, this may be a
    txDrain issue. For example running an application with the JDK on Win95 the port will drain before closing, but
    on WinNT data in the queue will be flushed (discarded). If your using WinNT see the notes regarding txDrain on
    WinNT.</P>

<P>Note: odd behavior has been noted when using txDrain on WinNT systems. If txDrain does not work as expected
    you may want to do something similar to the SerOutputStrem.flush method.</P>

<P><B>&quot;Sent only m of n bytes&quot;</B> where m is the number of bytes you want to send, and n is a number
    less than m. If you get this message when using putData(), your most likely filling up the transmit queue (your
    receiver can't keep up with your transmit rate). There are 3 ways to solve this issue. 1) Flush the queue after
    each send as is done in SerOuputStream.flush (this is recommended) 2) Check to see that the transmit queue has
    enough space in it (use SerialPortLocal.txBufCount() and SerialConfig.getTxLen()) 3) Increase setTimoutTx(0) to
    some value greater than 0 that will allow your app to work based on rate at which the receiver can keep up with
    your sending.</P>

<P><B>MARK &amp; SPACE Parity</B> <BR>
    These are not supported on all platforms. These parity settings should work on platforms that support them (e.g.
    Win32).</P>

<P><B>DTR and RTS</B> <BR>
    <B><I>Some devices (e.g. some popular modems) require DTR and/or RTS to be set or they will not communicate with
        another device.</I></B> These settings are often required even if you do not wish to use handshaking (flow
    control).
    <B><I>If your program does not appear to be working, check that DTR is set to true (if your not setting handshake
        to RTC-CTS you may also need to set RTS to true)</I></B>. Does your device work with HyperTerm (or another
    terminal
    program) but not with JavaTerm, or your SerialPort code? This could be due to the fact that many of these programs
    default to setting the DTR line <I>true</I> and selecting RTS-CTS handshaking, while SerialPort defaults to having
    DTR <I>false</I> with no handshake.</P>

<P><B>Ring Indicator (RI)</B> <BR>
    If you find your not able to detect changes on the RI pin (DB-9 pin 9, DB-25 pin 22) check the following: <BR>
    (Note: RI reports rings on incoming calls to the modem, NOT on rings created when the modem dials a number. i.e.
    RI is not a call progress indicator)

<UL>
    <LI>Are you using a serial cable that has the RI pin wired through to your device?
    <LI>Check that your modem (or other device) is toggling the RI pin.
    <LI>Check that your serial hardware/driver supports RI, some models of multi-port serial cards do not support
        detection
        of RI.
    <LI>Note there is no RI pin on some types of serial port hardware (e.g. the Macintosh).
</UL>

<P>Note if your serial port hardware/driver does not support detection of RI, if your using a modem, then you can
    parse for the RING message the modem transmits when it detects a ring on the line.</P>

<P><B>Error Numbers</B> <BR>
    When attempting to open a serial port, if the OS returns an error code SerialPort will first try to match it with
    an expected error code (e.g. 'Port in use'). If the error code returned is not expected the number is simply
    reported.
    For example &quot;<FONT FACE="Courier New, Courier">SerOpenPort failed: 13</FONT>&quot;. The meaning of this number
    is platform dependent. For Unix platforms the meaning of this number is defined in errno.h. For Windows platforms
    the definition is defined by GetLastError(). One listing of error numbers defined by GetLastError is <A
            HREF="http://www.serialio.com/support/Win32ErrorNumbers.htm">here</A>.</P>

<P><B>Non-Indexed BitRates</B><BR>
    Some platforms provide non-indexed bitrate settings. Indexed bitrates are used follows e.g. 19,200 bps</P>

<UL>
    <P><TT>&nbsp; serCfg.setBitRate(SerialConfig.BR_19200);</TT>
</UL>

<P>To use a non-indexed bitrate (if supported by the platform) simply use the rate as the parameter instead of
    the index value e.g. 14,400 bps</P>

<UL>
    <P><TT>&nbsp; serCfg.setBitRate(14400);</TT>
</UL>

<P>
<H4><U>RS485 - RS232 converters</U></H4>

<P>Many RS232-RS485 converters have a UART, which is jumper selectable between RS485-RS232. The UART handles the
    differences between the RS485-RS232 for the OS. The difference between using the RS485 over the RS232 system is
    that since RS485 is a multidrop line, you must tell the UART that it is ready to receive data when it is not sending
    data. To do this, you generally invoke a setRTS(false) when the output buffer is empty, and setRTS(true) before
    the send. This way the UART knows to<BR>
    grab the data on reply and send it to the rxQueue.</P>

<P>Please note that you can make an application that works fine on one machine, but may fail on another. The reason
    for this is essentially due to two things, machine speed, and driver implementation. The difficulty is that you
    have no way to know what the driver means when it tells you the send is 'done'. Does it mean the transmit queue
    is empty? or that the last byte has been sent from the UART hardware buffer? There is not a standard way to
    determine
    this, but <I>generally</I> it means the former, and therein lies the problem.</P>

<P>When the driver says the send is 'done' (e.g. SerialPort.txDrain() returns, OutputStream.flush() returns, or
    or you get a OUTPUT_BUFFER_EMPTY event) this <I>generally</I> means that the transmit queue is empty, but the UART
    buffer may still be sending data (esp in the case of a UART with a 1024 byte hardware buffer like the Comtrol
    RocketPort
    has). So on a 'slow' machine your code may could work fine, because the setRTS(false) does not execute until after
    the UART is empty and everything works fine, but on a 'fast' machine, the setRTS(false) occurs before the UART
    is done sending and things may fail.</P>

<P>The first thought to solve this problem is to add a sleep a certain amount of time after the the transmit, and
    before the setRTS. The problem here is you can't know how big the UART transmit buffer is, so how long do you sleep?
    There are two sure ways to know that you have a cross-platform solution: 1) Use a converter or driver that allows
    you to know when the UART is empty. 2) Sleep based on the size of the total data size sent and the bitrate (*if*
    you know that handshake (flow control) will not slow the transmit).</P>
<H4><U>Win32 Notes</U></H4>

<P>The <I>default Microsoft</I> Win32 COMM drivers are not bug free, 3rd party drivers are generally better. SerialPort
    was developed to be used on systems that operate 24 hrs per day, 365 days per year, and thus <I>SerialPort addresses
        the OS issues so that your application can be as solid as possible</I>. SerialPort also addresses OS issues that
    may occur when using the serial port for <I>unusual</I> applications (e.g. custom scanner). You will generally
    not have to be concerned with some of these issues if your doing <I>common</I> serial port applications (e.g.
    modems).
    We choose to make our customers of the OS issues instead of hiding them. The following notes will point out some
    of the Win32 bugs, and some issues you should be aware of when using SerialPort on a Win32 platform (i.e. Win95,
    WinNT, Win98).</P>

<P>With Win32, 3rd party drivers are used to provide functionality for hardware not supported by the default Win32
    COMM drivers. For example if you are using a Comtrol RocketPort, the drivers supplied by Comtrol are used when
    making serial port calls to Win32. If your application uses a multiport serial product that comes with Win32 drivers
    (like Comtrol, Digi, etc.) SerialPort will be making use of the 3rd party drivers. If your application uses the
    default PC serial ports, or you have a 'dumb' multiport serial card (like a Boca 2016) SerialPort will be using
    the <I>default Microsoft</I> COMM driver (the one with bugs, that SerialPort provides workarounds for).</P>

<P><I>Registry listing of serial ports</I> <BR>
    When using the feature that allows port discovery by reading the system registry, you may find that the Registry
    does not report ports that actually exist and are working on the target machine. This can be due to a corrupt
    Registry,
    or because the software that installed the serial port(s) on your machine did not create a registry entry. To create
    a registry entry for a port run REGEDIT and open the key <BR>
    &nbsp;&nbsp;&nbsp; HKEY_LOCAL_MACHINE <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HARDWARE <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICEMAP <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERIALCOMM <BR>
    then right-click on the mouse in the right window, select <I>New | String Value, </I>and enter a value <I>Name</I>
    (e.g. Serial2). Now right-click the entry you just created and select <I>Modify</I> and enter the device name in
    <I>Value Data</I> (e.g. COM3).</P>

<P><I>Win95 COMM driver</I> (Microsoft)<BR>
    This driver does not properly perform hardware flow control (RTSCTS or DTRDSR) when using non-overlapped I/O.
    Software
    (XONXOFF) flow control is done correctly. By default, SerialPort will workaround this bug by creating a flow control
    thread when a SerialPort object is created under Win95. This thread priority is adjusted to be one greater than
    the default priority. If your application creates threads with priorities greater than the default, be sure to
    adjust this threads priority to be one higher than your highest priority thread. This thread sleeps most of the
    time, so your application should not suffer any performance problems doing this. Remember this problem only exists
    with the <I>Microsoft provided</I> COMM driver on Win95, so when you're using 3rd party drivers (these generally
    come with multiport cards) this control thread is not required. This flow control method works with all tested
    Win95 drivers, but should you wish to disable this control thread use SerialConfig.setHardFlow, for example if
    your SerialConfig object is serCfg do the following:

<UL>
    <TT>serCfg.setHardFlow(false);</TT>
</UL>

<P>Be sure setHardFlow is <TT>false</TT> when running on NT (this is the default).</P>

<P>Another problem with the Win95 COMM driver is related to changing the state of DTR when data is in the transmit
    queue. This is generally not a problem when communicating with 'normal' devices (e.g. like modems), but should
    your device require you to toggle the DTR line, be sure to <I>flush the transmit queue before</I> the state of
    the DTR line or the port may lock up. This issue will generally not affect your application unless your doing
    communicating
    with an <I>unusual</I> device.</P>

<P><I>Microsoft Brand Java</I> <BR>
    Tests have shown the VM for Microsoft Java SDK 2.0 (the VM is actually included with with IE4.0) may not be stable
    when running the hardware flow control thread (created only on Win95 when hardware flow control is set) so you
    should use SerialConfig.setHardFlow(false) as discussed above. Consider using handshake of NONE, or XON/XOFF in
    this case.</P>

<P>With some versions of JVC it has been noted that some of the JSP example programs do not compile unless the
    object package name is used. For example if the code does this:</P>

<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; SerialConfig serCfg = new SerialConfig(devName);</TT></P>

<P>and the compiler fails, try changing the code to this:</P>

<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; Serialio.SerialConfig serCfg = new Serialio.SerialConfig(devName);</TT></P>

<P>This is only an issue with the Microsoft compiler.</P>

<P><I>Win98 COMM driver</I> (Microsoft)<BR>
    Win98 has a bug that prevents the function which provides the number of bytes in the input queue to always return
    0 until at least one byte of data is sent out the port after the port has been opened. This means if your code
    opens the port, then uses the rxReadyCount method to start looking for data (and nothing has been transmitted)
    your code will never see data on the input. We choose not to transmit a dummy byte when the port is opened (to
    'hide' the Microsoft bug), since this could have undesired affects for certain types of devices.</P>

<P>Win98 has another bug with the timeout feature of the driver. The method SerialPortLocal.setTimeoutRx(0) tells
    the driver to timeout immediately if the requested amount of data is not available. For example a call to
    SerialPortLocal.getData(buf)
    with a buf that has a length of 128 bytes, when there are only 50 bytes in the receive queue, should return
    immediately
    with the 50 bytes that are ready. This works on Win95 and WinNT, but not on Win98, on Win98 the read would block
    indefinitely until 128 bytes are ready.</P>

<P><I>WinNT COMM driver</I> (Microsoft)<BR>
    Win32 threading behaviour is not consistent between Win95 and WinNT. For example: Consider a Java application two
    threads using the same COM port, one for reading and one for writing. Suppose you send a large packet of data to
    the port for transmission to some serial device connected to the port, and that device is currently not ready to
    recieve data (assume it has not enabled your CTS). The transmit call will block until the packet has been sent.
    If at the same time your read thread checks for available incoming data, on WinNT your read thread will block until
    the write thread is finished, while on Win95/98 your read thread will function as expected, not blocking if the
    transmit thread is using the port.</P>

<P>The work around for this is is twofold and works for most applications. First keep the data packets that are
    transmitted small enough for required responsiveness to incoming data. Second keep the receive timeout set to 0
    when running on NT so the transmit thread will not be blocked if there is not data. Also use the Java Thread.sleep
    method to keep the thread running efficiently. Be sure to adjust the sleep time and/or receive buffer size so that
    it will not overflow at the selected bitrate during the time the thread is sleeping. Again, this is a WinNT issue
    only, Win95/98 do not exhibit this problem.</P>

<P>Another issue to be aware of with WinNT is when terminating a thread while the transmit buffer is not empty.
    The current implementation of SerialPort requests the OS to drain the transmit queue before returning from the
    native call. WinNT however may not properly drain the transmit queue, and in this case transmit data could be lost.
    To insure your WinNT implementation drains the transmit queue before terminating, you can do the following:

<UL>
    <TT>sp.txDrain();</TT>
</UL>

<P>or

<UL>
    <TT>while (sp.txBufCount() &gt; 0) Thread.sleep(10);</TT>
</UL>

<P>Win32 Note: When running Java on Win32 and using Thread.sleep, you should try to construct your code such that
    the parameter to sleep is 10ms or greater. Our experience with multiport applications running multiple threads
    indicates that values less than 10ms may not allow other threads to run as expected.</P>

<P><I>WinNT device names</I> <BR>
    When you open a port by name, and the port number is greater than 9 you must use special naming on WinNT. For
    example
    to open COM10 you need to use the name &quot;<TT>\\.\COM10</TT>&quot;. This naming convention also generally applies
    to other serial device names, for example if your serial device is &quot;<TT>MPSerial0_A</TT>&quot; you will
    probably
    need to use the name &quot;<TT>\\.\MPSerial0_A</TT>&quot; to open it.</P>

<P>If you have <B><I>version 3.2 </I></B>or later of SerialPort for Windows using the &quot;<TT>\\.\</TT>&quot;
    prefix is optional.</P>

<P><I>WinNT driver reliability (NT4-SP3)</I> <BR>
    Some customers have noted, and we have observed in-house, that something in the WinNT serial driver mechanism (the
    code in the OS) lacks high-reliability. This problem has only been observed only in server applications (running
    on NT Workstation or NT Server) that run 24/365 (24 hours per day 365 days per year), so for many applications
    this is my not be an issue. The WinNT failure modes that have been observed are subtle. Some examples are the
    following:
    the driver for no apparent reason begins to abort when null characters are received. The driver fails to receive
    data if the DTR line is not set, regardless of the flow control setting. These failures are resolved by restarting
    WinNT. <I>None of these issues have been reported on any other platforms, or on WinNT when using 3rd party serial
        drivers like those for the Comtrol RocketPort</I>.</P>

<P><I>WinNT driver blocking</I> <BR>
    When data is sent to the serial driver on WinNT and there is not an active device on the port, WinNT can block
    indefinitely. For example, if you open a serial port, and you have a modem connected to the port, but the modem
    power is off, when data is written to the port (e.g. using putData) WinNT will block in the native code until the
    device is turned on. You can avoid this type of problem by using the sigDTR method to verify the modem is turned
    on (virtually every modem will set DTR active when powered up).</P>

<P><I>Win32 Overlapped IO</I> <BR>
    SerialPort does not use Win32 Overlapped IO. There are several reasons for this the most significant being
    inconsistency
    in behavior across the various Win32 platforms. Java implements an efficient multi-threading model and properly
    implemented (see the example code) Java provides a highly efficient method for blocking that is more cross platform
    consistent than if native code (i.e. Overlapped IO in the Win32 case) were used.</P>

<P><I>Applets using SerialPort with IE5</I><BR>
    If you plan to use SerialPort in an applet with Internet Explorer 5, note that the Java VM included initial builds
    of IE5 do not properly implement JNI. <I><B>This includes the Java VM in the build of IE5 that ships with
        Win98SE</B></I>
    (VM 5.0.0.3167). We have found that the <B>Java VM Release 5.0.0.3234 </B>appears to work properly. To use
    SerialPort
    with IE, be sure you install IE5.01 which contains the above version of the VM.</P>

<P>Unfortunately, we cannot say with confidence IE5.01 or later. It is our experience (working with Java and IE
    since 1996) that MS many times has broken things in later releases that work in early versions. Why they do this
    is unclear.</P>

<P><B><U>Performance Notes:</U></B></P>

<P>To provide a simple benchmark to indicate relative performance for some Popular OS's we created a test program
    that ran as the only user task on the system. The test simply repeatedly called to check the status of the CD line
    (SerialPortLocal.sigCD). The following numbers indicate the number of calls per second. The tests were conducted
    on the identical hardware capable of multi-booting the various operating systems. JDK 1.1.2 running interpreted
    (i.e. no JIT) was used on a P166 with 64MB EDO DRAM. <BR>
    &nbsp;
<CENTER>

    <TABLE BORDER="1" WIDTH="75%" COLS="2">
        <TR>
            <TD>Platform OS</TD>
            <TD>Reads per second</TD>
        </TR>
        <TR>
            <TD>Linux (Caldera OpenLinux 1.1)</TD>
            <TD>90,000</TD>
        </TR>
        <TR>
            <TD>Windows 95</TD>
            <TD>56,200</TD>
        </TR>
        <TR>
            <TD>Windows NT</TD>
            <TD>6,900</TD>
        </TR>
    </TABLE>
</CENTER>
To give some indication as to the performance of a JIT consider the same test above run on JDK 1.1.6. JDK 1.1.6
is was not available for Linux at the time of this test so these numbers were not obtainable. <BR>
&nbsp; <BR>
&nbsp;
<CENTER>

    <TABLE BORDER="1" WIDTH="75%" COLS="3">
        <TR>
            <TD>Platform OS</TD>
            <TD>Interpreted (reads/sec)</TD>
            <TD>JIT (reads/sec)</TD>
        </TR>
        <TR>
            <TD>Windows 95</TD>
            <TD>58,800</TD>
            <TD>128,200</TD>
        </TR>
        <TR>
            <TD>Windows NT</TD>
            <TD>8,300</TD>
            <TD>9,900</TD>
        </TR>
    </TABLE>
</CENTER>
In terms of Java thread grain, we found that Win95 and Unix variants were also significantly more fine grained
when running multiple serial ports than is WinNT. For example assume your application has 8 ports, and each port
is receiving data at 9600 bps in a separate Java thread. If you displayed incoming data for each port in a separate
window, on Win95 the data would appear in each window somewhat simultaneously. Running the identical application
on WinNT you would see the received data displayed in chuncks one window after the other. Note All of these performance
numbers will be acceptable for most any application with proper buffer settings in the port configuration. These
performance numbers reflect <I>very high</I> method call frequency, and will only affect unusual applications (e.g.
some of our customers transfer data using changes in the RI line which must be polled <I>very</I> frequently).</P>
<H4><B><U>Macintosh Notes:</U></B></H4>
<H4><B>Opening a Port</B></H4>

<P>On the Macintosh, you may open a port using either a port name or a port number. The standard Mac port names
    are &quot;Modem Port&quot; and &quot;Printer Port&quot;; or you may use the number 1 for the modem port and 2 for
    the printer port. If you have third-party serial ports installed in your Mac, these ports can also be opened using
    a name or a number. The preferred method is to use the port name. When both a name and a number are present, the
    SerialPort object will use the name, not the number.</P>

<P>The names for your additional serial ports should be available in the documentation for your plug-in board.
    If you have any doubts about the port names you can find all of them by using a freeware utility called PortPeek.
    This extremely useful software can also force closed any port that is presently open, something you will inevitably
    need to do when you are debugging your own code. PortPeek is available for download at no charge from Megawolf,
    Inc. <A HREF="http://www.megawolf.com">(http://www.megawolf.com)</A>
<H4><B>Multiple ports/VMs</B></H4>

<P>On some Macintosh variants, it has been observed when running multiple VMs for multiple ports, that the CPU
    utilization is very high. This apparently has to do with the way in which the Mac implements VM threading. If you
    observe this behavior using multiple copies of JavaTerm, you can modify the JTermRcvTask.java on the line that
    contains <FONT FACE="Courier New, Courier">sleep(10);</FONT> Change the 10 to some larger number so that the receive
    queue is not polled so frequently. Note that when changing this value, be sure the receive buffer size is large
    enough to hold the number of characters that could be received before your application services the queue. For
    example if your application runs at 9600 bps, then you could receive about 960 bytes per second. If you set the
    sleep value to 1000 (i.e. 1 second) then the default 4096 byte queue size should suffice. If your using the
    javax.comm.SerialPort
    API there is a similar parameter in the file SerialPortEventTask.java, you will need a Professional license to
    obtain the source code to modify this parameter.
<H4>SerTxBufCount</H4>

<P>The txBufCount method is supported with boolean functionalitonly on Mac. This means that if there is data in
    the transmit buffer, this method returns 1 regardless of the amount of data in the buffer. This is not a limitation
    of SerialPort, the MacOS only indicates if there is data in the transmit buffer or not, it does not provide a count.
    This is sufficient for almost all serial port applications, as the most common need to know the status of the
    transmit
    buffer is to know if it is empty or not.</P>

<P><B>Macs with USB ports</B></P>

<P>The newest Apple computers do not have any built in serial ports. But there are third party products that let
    you add them to all of the current Macintosh models.</P>

<P>For any Macintosh with a PCI slot, such as the G3 towers, there are PCI expansion cards with multiple serial
    ports. One place to learn about these is www.megawolf.com. This web site provides lots of useful information about
    serial ports. You can also download free serial port utility software. MegaWolf sells a line of PCI serial port
    cards that can be used with many Macintosh models, not just the G3.</P>

<P>The iMac has no PCI slots, but it is still possible to add a serial port. Griffin Technology makes a product
    called the iPort which plugs inside of the iMac. For more information, check out their web page at
    www.griffintechnology.com.</P>

<P>USB to serial converters are available from Momentum (<A HREF="http://www.entrega.com">www.entrega.com</A>)
    and Keyspan (<A HREF="http://www.keyspan.com">www.keyspan.com</A>).</P>

<P>In addition to the serial port hardware, these manufacturers provide serial port driver software. The driver
    software &quot;registers&quot; the serial ports with the operating system using Apple's Communications Toolbox
    API. This is a standard interface that has been part of the Mac OS as far back as System 7.</P>

<P>The Communications Toolbox also provides a way for software applications to discover the added serial ports
    and use them in the same way as the &quot;traditional&quot; modem and printer ports. The Java SerialPort library
    uses the Communications Toolbox. This allows it to work with any added serial ports just as it works with the built
    in serial ports.</P>

<P>In general, any serial port hardware that uses the Communications Toolbox will work with the Java SerialPort
    library. If you do not know if the hardware that you have in mind uses the Communications Toolbox, contact the
    manufacturer of the hardware. They will be sure to know.</P>

<P><B>Writing individual bytes</B></P>

<P>There is a known issue with writing single bytes of data to 'fast' Macs. The workaround requires you to flush
    after each transmit. Adding a flush to the native code would have a negative affect on performance for some
    applications.
    You may need to add the flush to your Java code.</P>

<P>For example, you can use the following code: <BR>
    &nbsp;

<BLOCKQUOTE>
    <P><TT>for (byte anotherByte = 0;&nbsp; anotherByte&nbsp; &lt; 100; anotherByte ++) {</TT>
</BLOCKQUOTE>


<BLOCKQUOTE>
    <BLOCKQUOTE>
        <P><TT>serialOutputStream.write(anotherByte);</TT> <BR>
            <TT>serialOutputStream.flush();</TT>
    </BLOCKQUOTE>
    <P><TT>}</TT>
</BLOCKQUOTE>

<P>or, this may be a better solution.

<BLOCKQUOTE>
    <P><TT>for (byte anotherByte = 0;&nbsp; anotherByte&nbsp; &lt; 100; anotherByte ++) {</TT>
</BLOCKQUOTE>


<BLOCKQUOTE>
    <BLOCKQUOTE>
        <P><TT>serialOutputStream.write(anotherByte);</TT> <BR>
            <TT>while (serialPort.txBufCount() &gt; 0) {</TT>
        <BLOCKQUOTE>
            <P><TT>java.lang.Thread.sleep(1);</TT>
        </BLOCKQUOTE>
        <P><TT>}</TT>
    </BLOCKQUOTE>
    <P><TT>}</TT>
</BLOCKQUOTE>

<P>But the preferred solution is to add your bytes to an array, write the array, and then flush.

<BLOCKQUOTE>
    <P><TT>int&nbsp; byteCount = 100;</TT> <BR>
        <TT>byte[]&nbsp; output = new byte[byteCount];</TT></P>

    <P><TT>for (byte anotherByte = 0;&nbsp; anotherByte &lt; byteCount;&nbsp; anotherByte ++) {</TT>
    <BLOCKQUOTE>
        <P><TT>output[anotherByte] = anotherByte;</TT>
    </BLOCKQUOTE>
    <P><TT>}</TT></P>

    <P><TT>serialOutputStream.write(output);</TT> <BR>
        <TT>serialOutputStream.flush();</TT>
</BLOCKQUOTE>

<H4><B><U>Netscape Communicator</U></B></H4>

<P>To use SerialPort with Communicator it must support JNI (all in versions later than version 4.5 should have
    this). Assuming you have Communicator installed in the default directory on Windows, you must then do the
    following:</P>

<P>1) Put <I>signed</I> copy of Serialio.jar (and jspComm.jar if using the CommAPI) into &quot;c:\program
    files\netscape\communicator\program\java\classes&quot;
    (or a <I>signed</I> version of some JAR that contains the clasess used from the SerialPort package)<BR>
    2) Put a copy of the jspWin.dll file into c:\program files\netscape\communicator\program\java\bin</P>

<P>Note that your applet must be 'Trusted' to load the native DLL and you must enable the necessary privileges.
    For example</P>

<P><FONT FACE="Courier New">String JavaVendor = System.getProperty(&quot;java.vendor&quot;); <BR>
    if (JavaVendor.startsWith(&quot;Netscape&quot;)) {<BR>
    try{ <BR>
    PrivilegeManager.enablePrivilege(&quot;UniversalLinkAccess&quot;);<BR>
    }catch(Exception err){ err.printStackTrace();}<BR>
    }</FONT></P>

<P>Note when running an applet on Netscape, the static code in SerialPortLocal will generally execute before the
    privileges have been enabled, and thus the shared lib will not be loaded by the static block. To ensure the shared
    lib is loaded when running an applet on Netscape be sure to call the void SerialPortLocal constructor e.g.</P>

<P><FONT FACE="Courier New">SerialPortLocal sp = new SerialPortLocal();</FONT></P>

<P><FONT FACE="Courier New"></FONT></P>
<H4><B><U>Servlets for JavaServer</U></B></H4>

<P>To run Java servlets that use SerialPort and execute on JavaServer you can do one of the following.

<UL>
    <LI>Create the directory $SERVER_HOME/classes/Serialio and copy the Serialio classes there. ($SERVER_HOME is the
        directory where you installed JavaServer)
</UL>


<UL>
    <LI>Start JavaServer with the httpd.nojre script. This bypasses the included JRE so if you have a SerialPort
        application
        that works outside the server, it should work as a servlet when the server is started this way. Remember, the
        httpd
        script ignores the CLASSPATH by default.
</UL>

<P>If you don't perform one of these, you will probably get a ClassNotFoundException report when your servlet executes.
    <BR>
    &nbsp;
<H4><B><U>Visual Cafe Notes (2.0 PDE and later - Win32)</U></B></H4>

<P>This option is supported only with Standard and Professional SerialPort packages.</P>

<P>Since much of the Serialio package runs at the native level, performance benefits gained by compiling to Win32
    EXE will be minimal. A good JIT is nearly as fast as a Win32 EXE, and when you build a Win32 EXE you loose the
    cross-platform benefits of Java byte-code class files. For these reasons building Win32 EXEs with SerialPort is
    generally not required.</P>

<P>If you wish to use Visual Cafe 2.0PDE or later make native Win32 EXE files that use SerialPort do the following.</P>

<P>We assume here your Visual Cafe 2.x is installed in C:\VC2, if your installation is different adjust the directory
    name appropriately. The source code modifications (see step a) below) are required because you loose the dynamic
    binding of Java when you build Win32 EXEs, (i.e. all native methods must be resolved at compile time).</P>

<P>a) Comment 2 lines in SerialPortLocal.java marked &quot;comment for win32 exe&quot;</P>

<P>1) Create the directory C:\VC2\Java\Lib\Serialio. <BR>
    2) Copy the Serialio Java source files to the directory in 1). <BR>
    3) Copy the file jspWin.LIB to the directory in 1). <BR>
    4) In the &quot;Insert...Files into project&quot; option add the Serialio Java source files to your project (from
    the directory in 1)). <BR>
    5) In the &quot;Project...Options...Project Type&quot; setting select &quot;Win32 Application - A stand-alone
    executable
    program&quot;. <BR>
    6) In the &quot;Project...Options&quot; select the &quot;Compiler&quot; tab then select the &quot;Compiler Category&quot;
    to &quot;Libraries (Win32 only)&quot;. <BR>
    7) Click the new button and add the file jspWin.LIB from the SerialPort package to the list.</P>

<P>Notes: <BR>
    a) Do <B>not</B> put the Serialio package classes in the same directory as your project files. <BR>
    b) Note Win32 EXEs created by VC2.0PDE require (at least) jspWin.DLL and Symantec DLLs snjawt11.dll, snrt11.dll
    <BR>
    c) If you rebuild the native Win32 DLL on Microsoft VC++ 6, you will need to use <B>implib.exe</B> instead of <B>coff2omf.exe</B>
    to convert the lib to the proper format for Visual Cafe. Last we checked, this file was available at
    http://www.service1.symantec.com/support/devtools.nsf/docid/1998789589</P>
<H4><B><U>Visual Cafe 4 Notes</U></B></H4>

<P>When building an EXE with Visual Cafe 4, you will need to copy the jspWin.dll to snjjspWin2.dll. This workaround
    is outlined at&nbsp;http://www.service1.symantec.com/support/devtools.nsf/docid/2000010614205205</P>

<P>The EXE produced by Visual Cafe 4 is quite different from the EXE produced by Visual Cafe 3 &amp; 2. The Visual
    Cafe 4 EXE is more like a stub EXE (similar to what Microsoft does with their JVIEW). For example the JavaTerm
    CommAPI example when built as an EXE on VC3 is 476KB, yet when built on VC4 is 152KB.</P>
<H4><B><U>JBuilder 3 Notes (Win32)</U></B></H4>

<P>The JBuilder IDE requires project setting changes to find the SerialPort classes. To make these changes assume
    first that your Serialio.jar file is located in the folder C:\JLib\Serilio.jar. Select Project | Properties | Paths
    | Add | New | Name: Serialio | Class path: c:\JLib\Serialio.jar | OK. Your project will not work (from the IDE)
    unless this is done you will get an error saying that it can't open directory Serialio. You would expect that
    putting
    SerialPort classes in \lib\Serialio or putting Serialio.jar into JBuilder\Java\jre\lib\ext would work but it does
    not. If your using javax.comm, you will need to do the same thing as outlined above for Serialio.jar for
    jspComm.jar.</P>

<P><B><U>JavaTerm CommAPI EXE project files (Enterprise Windows package only)</U></B></P>

<P>Follow these steps to setup the JavaTerm Comm API application project. We assume Visual Cafe 4 is installed
    in D:\VCafe4 and that the Serialio package was unpacked to D:\jsp. There is more than one way to do this, this
    is one way. Note if you use different directories than this example you will need to change the included Visual
    Cafe project file.</P>

<P>1) Create these directories</P>

<BLOCKQUOTE>
    <P>- Project directory e.g. D:\VCafe4\Projects\JTC</P>

    <P>- Create D:\VCafe4\Java\Lib\Serialio directory</P>

    <P>- Create D:\VCafe4\Java\Lib\javax\comm directory</P>
</BLOCKQUOTE>

<P>2) Copy these files</P>

<BLOCKQUOTE>
    <P>- Project files from D:\jsp\ProWin to D:\VCafe4\Projects\JTC</P>

    <P>- Application files from D:\jsp\Core\CommAPI\Examples\JavaTerm to to D:\VCafe4\Projects\JTC.</P>

    <P>- Serialio files from D:\jsp\SerialioSrc to D:\VCafe4\Java\Lib\Serialio.</P>

    <P>- Comm API files from D:\jsp\CommAPISrc to D:\VCafe4\Java\Lib\javax\comm.</P>
</BLOCKQUOTE>

<P>
<H4><B><U>Visual Cafe and Java Beans</U></B></H4>

<P>This section outlines the creation of a simple Java dialer application using the SerialPortLocal Bean with Visual
    Cafe 2.0 and later. This application should work with most popular modems.</P>

<P>If you have not installed the SerialPortLocal Bean do the following:</P>

<P>1) Open Visual Cafe <BR>
    2) Insert the SerialPortLocal Bean into the Component Library (Menu selection: Insert | Component Into Library)</P>

<P>Create a dialer application using the SerialPortLocal Bean</P>

<P>1) Create a new application (Menu selection: File | New Project | Basic Application) <BR>
    2) Drag a button onto the application form and label the button &quot;Dial&quot;. <BR>
    3) Drag a button onto the application form and label the button &quot;On Hook&quot;. <BR>
    4) Drag a SerialPortLocal icon onto the application form. <BR>
    5) From the VC Properties Window, set the &quot;Port Name&quot; to where the modem is installed (e.g. COM3).</P>

<P>6) Insert the following code at the end of the VC generated constructor: <BR>
    <TT>&nbsp; try {</TT> <BR>
    <TT>&nbsp;&nbsp; serialPortLocal1.open();</TT> <BR>
    <TT>&nbsp; }</TT> <BR>
    <TT>&nbsp; catch(java.io.IOException e) {</TT> <BR>
    <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</TT> <BR>
    <TT>&nbsp; }</TT></P>

<P>7) Add an interaction for the &quot;Dial&quot; button and use the following code: <BR>
    <TT>&nbsp;&nbsp; try {</TT> <BR>
    <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serialPortLocal1.setDTR(true);</TT> <BR>
    <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try { Thread.sleep(500); } catch(Exception e) {}</TT>
    <BR>
    <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        serialPortLocal1.putString(&quot;ATDT5551212\r&quot;);</TT>
    <BR>
    <TT>&nbsp;&nbsp; }</TT> <BR>
    <TT>&nbsp;&nbsp; catch(java.io.IOException e) {</TT> <BR>
    <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</TT> <BR>
    <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT></P>

<P>8) Add an interaction for the &quot;On Hook&quot; button and use the following code: <BR>
    <TT>&nbsp;&nbsp; try {</TT> <BR>
    <TT>&nbsp;&nbsp;&nbsp; serialPortLocal1.setDTR(false);</TT> <BR>
    <TT>&nbsp;&nbsp; }</TT> <BR>
    <TT>&nbsp;&nbsp; catch(java.io.IOException e) { }</TT> <BR>
    <TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</TT> <BR>
    <TT>&nbsp; }</TT></P>

<P>When the application is run clicking the &quot;Dial&quot; button should dial the programmed number, clicking
    the &quot;On Hook&quot; button should hang up the line. <BR>
    &nbsp;</P>

<P><B><U>Java Plug-in CLASSPATH Notes</U></B></P>

<P>When running Applets with the Java Plug-in you should note the following CLASSPATH precedence. If you reference
    a class, the VM will look first in the JRE (Plug-in) ext folder (default is C:\Program
    Files\Javasoft\JRE\1.2\lib\ext).
    Next is searches the CLASSPATH environment variable on the local machine, and finally it looks in the codebase
    (normally on the web server). This means when class is referenced, the version in your codebase will not be used
    if it also exists in ext and/or CLASSPATH.
<H4><B><U>J++ and JNI</U></B></H4>

<P>SerialPort 4.2 and later assume that the Microsoft Java VM supports JNI. The JNI DLL has been tested with Microsofts
    SDK for Java 3.2 and VM build 3181. If you wish to use a Microsoft VM that does not support JNI (i.e. uses RNI),
    then uncomment the following lines in SerialPortLocal.java.</P>

<P><TT>//&nbsp;&nbsp;&nbsp; if (vendor.equals(&quot;Microsoft Corp.&quot;)) {</TT> <BR>
    <TT>//&nbsp;&nbsp;&nbsp;&nbsp; jspLib = &quot;jspWinRni&quot;;</TT> <BR>
    <TT>//&nbsp;&nbsp;&nbsp;&nbsp; if (jdkVer.equals(&quot;1.0.2&quot;))</TT> <BR>
    <TT>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jspLib = &quot;jspWinRnia&quot;;</TT> <BR>
    <TT>//&nbsp;&nbsp;&nbsp; }</TT> <BR>
    &nbsp;
<H4><B><U>SuperCede Notes</U></B></H4>

<P>Only SuperCede 2.0 and later support JNI, therefore SuperCede versions previous to 2.0 will not work.</P>

<P>When building your application SuperCede may import jspWin.DLL to the Supercede environment. If this occurs
    the application may not function properly - a likely failure will be a NullPointerException. If this occurs remove
    the DLL from the import list of SuperCede. <BR>
    &nbsp;</P>

<P><B><U>Break Signal Notes</U></B> <BR>
    Sending breaks on Unix machines has a resolution of <I>about </I>250ms, while the resolution on Other platforms
    is about 1ms. The reason for this is the limitations of the tcsendbreak() function used at the native level. On
    Unix machines the duration of the break is between 250-500ms for each 250ms requested. For example of you use
    sendBreak(1000),
    you will get a break signal between 1000-2000ms. Using sendBreak(0) on Unix will generate a break between 250-500ms.
</P>

<P>In addition to issues with sending breaks, the receive break issues on Unix are also significant. Unix provides
    no Posix way to determine which port a break came from in a muli-port environment. Do not try to make apps that
    will run on a Unix machine that require the ability to determine which port a break signal came from. <BR>
    &nbsp;</P>

<P><B><U>Threading Notes on some Unix flavors</U></B> <BR>
    Many Unix implementations use Green Threads to implement threading in Java. When using multiple threads to implement
    send and receive tasks, you may find that transmit threads do not 'wake up' properly after blocking. For example
    if you use putData to send a large buffer, and putData should block (for flow control, or buffer full reasons)
    then the blocked thread may not 'wake up' unless a system interrupt is generated (e.g. a mouse move or a receive
    character on the serial port). This problem is known to exist in the Chapman port of the Sun JDK to Linux (at least
    through 1.1.3), and on the HP port of the Sun JDK 1.1.2. This issue appears to have been resolved with JDK 1.1.5
    on Linux. You will need glibc version 2 to get JDK 1.1.5 to work. If you're using RetHat 5.0 or later you should
    have the corrrect version of glibc. We recommend using JDK 1.1.5 or later on Linux.</P>

<P><B><U>Unix Deamons and serial ports </U></B><BR>
    Most Unix implementations allow ports to be opened by more than one device. If you have a problem where you can
    send, but you can't receive, check to see that the port your using is not mapped to the mouse daemon (or opened
    by some other software)</P>

<P><B><U>Unix file privileges</U></B><BR>
    Remember that file privileges can be set to prevent processes with certain privileges from opening a port (which
    on Unix is controlled by the device file). If you try to open a port without sufficient privileges, you may get
    an error number from the native code e.g. &quot;<B>java.io.IOException: SerOpenPort failed: 13</B>&quot; from the
    native code. The error number is platform dependent. If you get this error on a Unix system, it is likely that
    your process does not have sufficient privileges to open the port, use <B>chmod</B> to change the device privileges.
</P>

<P><BR>
    <B><U>LINUX</U></B> <BR>
    The Linux serial driver (at least through kernel 2.0.29) always toggles the CTS line regardless of the handshake
    (flow control) setting. This is a function of the OS driver not the SerialPort native code. For split handshake
    this in effect means that HARD_OUT is always true even if not selected using SerialPort.</P>

<P><B><U>SGI IRIX</U></B> <BR>
    setDTR and setRTS are not supported <BR>
    CTSRTS handshaking is not supported. <BR>
    Only one stop bit is supported (not two).</P>

<P>With some versions of IRIX and the SGI JDK running on 64 bit CPU's, you may need to involke the MIPS ABI options.
    For example to use the MIPS o32 ABI by entering the command&nbsp; <B><I>java -32
        YourClassThatUsesSerialPort.</I></B></P>

<P><B><U>IBM AIX</U></B> <BR>
    BitRate is limited to 38,400 in the shared library release libjspAixPpc.so.2.7.</P>
<H4><B><U><A HREF="jspEpoc.html">EPOC32 on Psion Notes</A></U></B></H4>

<P><B><U>Cross-Platform Notes</U></B> <BR>
    If you plan for your Java application to run cross-platform, you must design your application with regard to the
    lowest common features. For example, if your application will run on a Macintosh, you cannot use the <I>setRTS</I>
    since standard Mac hardware does not have a RTS line. For details on platform specific issues see the <I>featureSetup
    </I>method in the Java source code.</P>

<P>Do not copy .ser files between platforms, if you do you will likely get the error &quot;Port device name not
    valid&quot; since the device names vary between platforms.</P>

<P><B><U>javax.comm API</U></B></P>

<P>Our implementation of the javax.comm API is done entirely using the SerialPort API. For documentation on javax.comm
    see the javax.comm documentation from Sun. Setup to use the javax.comm implementation is extreamly simple. First
    install SerialPort, then modify you CLASSPATH to include a reference to the javax.comm JAR file jspComm.jar.</P>

<P><B><U>JavaRing (Dallas Semiconductor iButton)</U></B></P>

<P>These notes are based on the Java iButton developers kit version 0.92. <BR>
    The examples below assume

<UL>
    <LI>SerialPort has been installed per instructions
    <LI>The iButton JARs in c:\jib
    <LI>The Comm API JAR jspComm.jar is in c:\jsp
    <LI>The opencard properties settings are correct, and located in
        <UL>
            <LI>[java.home]/jre/lib/opencard.properties (for JDK 1.2 when JRE installed)
            <LI>[java.home]/lib/opencard.properties
            <LI>[user.home]/.opencard.properties
            <LI>[user.dir]/opencard.properties
            <LI>[user.dir]/.opencard.properties
        </UL>
</UL>

<P><BR>
    When using OpenCard to run Examples\Host\BusinessCardDemo\OpenCard\BusinessCardDisplay, you need the following
    in your CLASSPATH</P>

<P>c:\jsp\jspComm.jar;c:\jib\jibapi.jar;c:\jib\Exportable_Ocf.jar</P>

<P>When using apduSender, in addition to the above, you need the following in your CLASSPATH</P>

<P>c:\jib\apduSender.jar <BR>
    &nbsp; &nbsp;</P>

<P ALIGN="CENTER"><B><U>Contact US</U></B> <BR>
    If you have questions or comments please contact us. <BR>
    <B><FONT SIZE="4">Solutions Consulting</FONT></B> <BR>
    <B>support@serialio.com</B>

</BODY>

</HTML>